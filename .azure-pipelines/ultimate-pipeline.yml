trigger:
  branches:
    include:
      - master # Only run on master for now
    exclude:
      - refs/pull/*/head
  paths:
    exclude:
      - docs/*
      - .github/*
pr:
  branches:
    exclude: # Don't run PR validation for now
    - '*'

# Global variables
variables:
  buildConfiguration: Release
  dotnetCoreSdk5Version: 5.0.103
  relativeTracerHome: /src/bin/windows-tracer-home
  relativeArtifacts: /src/bin/artifacts
  tracerHome: $(System.DefaultWorkingDirectory)/src/bin/windows-tracer-home
  artifacts: $(System.DefaultWorkingDirectory)/src/bin/artifacts
  ddApiKey: $(DD_API_KEY)
  isMainBranch: $[eq(variables['Build.SourceBranch'], 'refs/heads/master')]
  DD_DOTNET_TRACER_MSBUILD:
  NugetPackageDirectory: $(System.DefaultWorkingDirectory)/packages
  relativeNugetPackageDirectory: packages

# Declare the datadog agent as a resource to be used as a pipeline service
resources:
  containers:
  - container: dd_agent
    image: datadog/agent
    ports:
    - 8126:8126
    env:
      DD_API_KEY: $(ddApiKey)
      DD_INSIDE_CI: true

# Stages
stages:
- stage: build_windows
  dependsOn: []
  jobs:
  - job: build
    pool:
      vmImage: windows-2019
    steps:
    - template: steps/install-dotnet-5-sdk.yml

    - script: build.cmd CreateRequiredDirectories --skip
      displayName: Create required directories

    - script: build.cmd RestoreNuGet --skip
      displayName: NuGet Restore

    - script: build.cmd CompileManagedSrc --skip
      displayName: Compile Managed src

    - script: build.cmd PublishManagedProfiler --skip
      displayName: Publish Managed Profiler

    - script: build.cmd CompileNativeSrcWindows --skip
      displayName: Compile native src

    - script: build.cmd PublishNativeProfilerWindows --skip
      displayName: Publish native profiler

    - script: build.cmd CopyIntegrationsJson --skip
      displayName: Copy integrations.json

    - publish: $(tracerHome)
      displayName: Upload Windows tracer home directory
      artifact: build-windows-tracer-home

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the managed build
      artifact: build-managed

    ## TODO: Move these to the package step?
    ## - script: build.cmd ZipTracerHome --skip
    ##   displayName: Zip tracer home directory

    ## - script: build.cmd BuildMsi --skip
    ##   displayName: Build the msi

    ## - publish: $(artifacts)/x86/en-us
    ##   displayName: Upload Windows x86 MSI
    ##   artifact: windows-msi-x86

    ## - publish: $(artifacts)/x64/en-us
    ##   displayName: Upload Windows x64 MSI
    ##   artifact: windows-msi-x64

    ## - publish: $(artifacts)/tracer-home.zip
    ##   displayName: Upload Windows tracer home zip
    ##   artifact: windows-tracer-home

- stage: build_linux
  dependsOn: []
  jobs:
  - job: build
    dependsOn: []
    strategy:
      matrix:
        debian:
          matrixName: debian
          poolName: Azure Pipelines
          vmImage: ubuntu-18.04
          baseImage: linux
        alpine:
          matrixName: alpine
          poolName: Azure Pipelines
          vmImage: ubuntu-18.04
          baseImage: alpine
        arm64:
          matrixName: arm64
          poolName: Arm64
          vmImage:
          baseImage: linux
    pool:
      name: $(poolName)
      vmImage: $(vmImage)

    steps:
    - script: |
        docker build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdk5Version) \
          --tag dd-trace-dotnet/$(baseImage)-base \
          --target builder \
          --file "$(System.DefaultWorkingDirectory)/build/_build/docker/$(baseImage).dockerfile" \
          "$(System.DefaultWorkingDirectory)/build/_build"
      displayName: Build Docker base image

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-base \
            dotnet /build/bin/Debug/_build.dll RestoreDotNet --skip
      displayName: Dotnet restore

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-base \
            dotnet /build/bin/Debug/_build.dll CompileManagedSrc --skip
      displayName: Compile Managed src

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-base \
            dotnet /build/bin/Debug/_build.dll PublishManagedProfiler --skip
      displayName: Publish Managed Profiler

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-base \
            dotnet /build/bin/Debug/_build.dll CompileNativeSrcLinux --skip
      displayName: Build native profiler

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-base \
            dotnet /build/bin/Debug/_build.dll PublishNativeProfilerLinux --skip
      displayName: Publish native profiler

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-base \
            dotnet /build/bin/Debug/_build.dll ZipTracerHome --skip
      displayName: Package native profiler

    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.ClrProfiler.Native/build/bin/Release/x64
      displayName: Uploading linux tracer home artifact
      artifact: build-linux-tracer-home-$(matrixName)

    - publish: $(artifacts)/linux-x64
      displayName: Upload linux packages
      artifact: linux-packages-$(matrixName)

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-linux-$(matrixName)

- stage: build_macos
  dependsOn: []
  jobs:
  - job: build
    dependsOn: [ ]
    pool:
      vmImage: macOS-10.15
    steps:
    - template: steps/install-dotnet-5-sdk.yml

    - script: ./build.sh CreateRequiredDirectories --skip
      displayName: Create required directories

    - script: ./build.sh RestoreDotNet --skip
      displayName: Dotnet Restore

    - script: ./build.sh CompileManagedSrc --skip
      displayName: Compile Managed src

    - script: ./build.sh PublishManagedProfiler --skip
      displayName: Publish Managed Profiler

    - script: ./build.sh CompileNativeSrcMacOs --skip
      displayName: Compile native src

    ## TODO: Move to Nuke target
    - script: |
        mkdir -p src/Datadog.Trace.ClrProfiler.Native/bin/netstandard2.0
        cp src/bin/windows-tracer-home/netstandard2.0/*.dll src/Datadog.Trace.ClrProfiler.Native/bin/netstandard2.0/
        mkdir -p src/Datadog.Trace.ClrProfiler.Native/bin/netcoreapp3.1
        cp src/bin/windows-tracer-home/netcoreapp3.1/*.dll src/Datadog.Trace.ClrProfiler.Native/bin/netcoreapp3.1/
      displayName: Copy files into build-macos-tracer-home

    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.ClrProfiler.Native/bin
      displayName: Uploading macos profiler artifact
      artifact: build-macos-tracer-home

    - publish: $(tracerHome)
      displayName: Upload tracer home directory
      artifact: build-tracer-home-macos

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-macos

- stage: package_windows
  dependsOn: build_windows
  pool:
    vmImage: windows-2019
  jobs:
  - job: msi_and_pack
    steps:
      - template: steps/install-dotnet-5-sdk.yml
      - template: steps/restore-working-directory.yml

      - script: build.cmd BuildMsi --skip
        displayName: Build MSI

      - script: build.cmd ZipTracerHome --skip
        displayName: ZIP Tracer home directory

      - script: build.cmd PackNuGet --skip
        displayName: Create NuGet packages

      - publish: $(artifacts)/tracer-home.zip
        displayName: Publish tracer-home.zip
        artifact: tracer-home.zip

      - publish: $(artifacts)/x86/en-us
        displayName: Publish Windows x86 MSI
        artifact: windows-msi-x86

      - publish: $(artifacts)/x64/en-us
        displayName: Publish Windows x64 MSI
        artifact: windows-msi-x64

      - publish: $(artifacts)/nuget
        displayName: Publish NuGet packages
        artifact: nuget-packages

- stage: unit_tests_windows
  dependsOn: build_windows
  pool:
    vmImage: windows-2019
  jobs:
    - job: managed
      steps:
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml

      - script: build.cmd CompileManagedUnitTests --skip
        displayName: Compile Managed Unit Tests

      - script: build.cmd RunManagedUnitTests --skip
        displayName: Run managed unit tests

    - job: native
      steps:
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml

      - script: build.cmd CompileNativeTestsWindows --skip
        displayName: Compile Native Unit tests

      - script: build.cmd RunNativeTestsWindows --skip
        displayName: Run Native Unit tests

      - task: PublishTestResults@2
        displayName: publish test results
        inputs:
          testResultsFiles: test/**/test*.xml
        condition: succeededOrFailed()

- stage: unit_tests_macos
  dependsOn: build_macos
  jobs:
  - job: managed
    pool:
      vmImage: macOS-10.15
    steps:
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml
        parameters:
          artifact: build-macos

      - script: ./build.sh CompileManagedUnitTests --skip
        displayName: Compile Managed Unit Tests

      - script: ./build.sh RunManagedUnitTests --skip
        displayName: Run managed unit tests

- stage: unit_tests_linux
  dependsOn: [build_linux]
  jobs:
  - job: test
    strategy:
      matrix:
        debian:
          matrixName: debian
          poolName: Azure Pipelines
          vmImage: ubuntu-18.04
          baseImage: linux
        alpine:
          matrixName: alpine
          poolName: Azure Pipelines
          vmImage: ubuntu-18.04
          baseImage: alpine
        arm64:
          matrixName: arm64
          poolName: Arm64
          vmImage:
          baseImage: linux
    pool:
      name: $(poolName)
      vmImage: $(vmImage)

    steps:
    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-linux-$(matrixName)

    - script: |
        docker build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdk5Version) \
          --tag dd-trace-dotnet/$(baseImage)-tester \
          --target tester \
          --file "$(System.DefaultWorkingDirectory)/build/_build/docker/$(baseImage).dockerfile" \
          "$(System.DefaultWorkingDirectory)/build/_build"
      displayName: Build Docker base image

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-tester \
            dotnet /build/bin/Debug/_build.dll CompileManagedUnitTests --skip
      displayName: Compile Managed Unit Tests

    - script: |
        docker run --rm \
            --mount type=bind,source="$(System.DefaultWorkingDirectory)",target=/project \
            --env NugetPackageDirectory=/project/$(relativeNugetPackageDirectory) \
            --env tracerHome=/project/$(relativeTracerHome) \
            --env artifacts=/project/$(relativeArtifacts) \
            dd-trace-dotnet/$(baseImage)-tester \
            dotnet /build/bin/Debug/_build.dll RunManagedUnitTests --skip
      displayName: Run managed unit tests

- stage: integration_tests_windows
  dependsOn: build_windows
  pool:
    vmImage: windows-2019
  jobs:

  - job: Windows
    timeoutInMinutes: 100
    strategy:
      matrix:
        x64:
          buildPlatform: x64
        x86:
          buildPlatform: x86

    steps:
    - template: steps/install-dotnet-sdks.yml
    - template: steps/restore-working-directory.yml

    - script: build.cmd CompileDependencyLibs --skip
      displayName: Build dependency libraries

    - script: build.cmd CompileManagedUnitTests --skip
      displayName: Compile Managed Unit Tests (has dependencies of integration tests)

    # The integration tests are built for x86/x64 specifically
    # which means they either need to rebuild all their dependencies,
    # or we use this hack
    - script: build.cmd CopyPlatformlessBuildOutput --skip
      displayName: Copy AnyCPU libs to x86/x64 folders

    - script: build.cmd CompileRegressionDependencyLibs --skip
      displayName: Build regression dependency libraries

    - script: build.cmd CompileRegressionSamples --skip
      displayName: Build regression dependency libraries

    - script: build.cmd CompileFrameworkReproductions --skip
      displayName: Build .NET Framework projects (non SDK-based projects)

    - script: build.cmd CompileSamples --skip
      displayName: Build samples

    - script: build.cmd CompileIntegrationTests --skip
      displayName: Build integration tests

    - script: build.cmd RunIntegrationTests --skip
      displayName: Run integration tests

- stage: integration_tests_windows_iis
  dependsOn: [build_windows, package_windows]
  jobs:
  - job: Windows_IIS
    timeoutInMinutes: 100
    strategy:
      matrix:
        x64:
          buildPlatform: x64
          enable32bit: false
        x86:
          buildPlatform: x86
          enable32bit: true
    pool:
      vmImage: windows-2019
    variables:
      msiOutputDirectory: src/WindowsInstaller/bin/$(buildConfiguration)/$(buildPlatform)/en-us

    steps:

    - template: steps/install-dotnet-sdks.yml
    - template: steps/restore-working-directory.yml

    - script: build.cmd CompileDependencyLibs --skip
      displayName: Build dependency libraries

    - script: build.cmd CompileManagedUnitTests --skip
      displayName: Compile Managed Unit Tests (has dependencies of integration tests)

      # The integration tests are built for x86/x64 specifically
      # which means they either need to rebuild all their dependencies,
      # or we use this hack
    - script: build.cmd CopyPlatformlessBuildOutput --skip
      displayName: Copy AnyCPU libs to x86/x64 folders

    - script: build.cmd CompileRegressionDependencyLibs --skip
      displayName: Build regression dependency libraries

    - script: build.cmd CompileRegressionSamples --skip
      displayName: Build regression dependency libraries

    - script: build.cmd CompileFrameworkReproductions --skip
      displayName: Build .NET Framework projects (non SDK-based projects)

    - task: MSBuild@1
      displayName: Publish IIS samples
      inputs:
        solution: test/test-applications/aspnet/samples-iis.sln
        configuration: '$(buildConfiguration)'
        msbuildArguments: '/p:DeployOnBuild=true /p:PublishProfile=FolderProfile.pubxml'
        maximumCpuCount: true

    - task: DockerCompose@0
      displayName: docker-compose build IIS containers
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: build --build-arg DOTNET_TRACER_MSI=$(msiOutputDirectory)/*.msi --build-arg ENABLE_32_BIT=$(enable32bit) IntegrationTests.IIS.LoaderOptimizationRegKey

    - task: DockerCompose@0
      displayName: docker-compose start IIS containers
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: up -d IntegrationTests.IIS.LoaderOptimizationRegKey

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the managed build
      artifact: build-integration-tests-windows-iis-$(buildPlatform)

    - powershell: |
        [System.Reflection.Assembly]::Load("System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")
        $publish = New-Object System.EnterpriseServices.Internal.Publish
        Get-ChildItem $(tracerHome)/net45 -Filter *.dll | Foreach-Object { $publish.GacInstall($_.FullName) }
      displayName: Add net45 Datadog.Trace.ClrProfiler.Managed assets to the GAC

    - task: DotNetCoreCLI@2
      displayName: dotnet test --filter LoadFromGAC=True
      inputs:
        command: test
        projects: test/Datadog.Trace.ClrProfiler.IntegrationTests/Datadog.Trace.ClrProfiler.IntegrationTests.csproj
        arguments: -c $(buildConfiguration) --filter "(RunOnWindows=True|Category=Smoke)&LoadFromGAC=True&IIS!=True" -p:Platform=$(buildPlatform)

    - task: DotNetCoreCLI@2
      displayName: dotnet test IIS
      inputs:
        command: test
        projects: test/Datadog.Trace.ClrProfiler.IntegrationTests/Datadog.Trace.ClrProfiler.IntegrationTests.csproj
        arguments: -c $(buildConfiguration) --filter "(IIS=True)" -p:Platform=$(buildPlatform)

    - task: DockerCompose@0
      displayName: docker-compose stop services
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: down
      condition: succeededOrFailed()

- stage: integration_tests_linux
  dependsOn: build_linux
  jobs:
  - job: Linux
    strategy:
      matrix:
        netcoreapp2_1:
          publishTargetFramework: netcoreapp2.1
        netcoreapp3_0:
          publishTargetFramework: netcoreapp3.0
        netcoreapp3_1:
          publishTargetFramework: netcoreapp3.1
        net5_0:
          publishTargetFramework: net5.0

    variables:
      TestAllPackageVersions: true

    steps:
    - template: steps/restore-working-directory.yml
     
     # TODO: implement build.sh in Build.cs 
     - task: DockerCompose@0
      displayName: docker-compose run build
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) -e publishTargetFramework=$(publishTargetFramework) build

    - script: |
        chmod +x $(System.DefaultWorkingDirectory)/build/docker/Datadog.Trace.ClrProfiler.IntegrationTests.sh
      displayName: 'Workaround: Restore wiped executable permission on build/docker/Datadog.Trace.ClrProfiler.IntegrationTests.sh'

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) -e publishTargetFramework=$(publishTargetFramework) IntegrationTests

    - publish: build_data
      artifact: $(Agent.JobName)_profiler-logs
      condition: succeededOrFailed()

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: test/**/*.trx
      condition: succeededOrFailed()

  - job: Alpine_Linux
    strategy:
      matrix:
        netcoreapp2_1:
          publishTargetFramework: netcoreapp2.1
        netcoreapp3_0:
          publishTargetFramework: netcoreapp3.0
        netcoreapp3_1:
          publishTargetFramework: netcoreapp3.1
        net5_0:
          publishTargetFramework: net5.0

    variables:
      TestAllPackageVersions: true

    steps:
    - checkout: none

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: build-managed
        path: $(System.DefaultWorkingDirectory)

    - download: current
      artifact: build-alpine-linux-tracer-home

    - task: CopyFiles@2
      inputs:
        sourceFolder: $(Pipeline.Workspace)/build-alpine-linux-tracer-home
        targetFolder: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.ClrProfiler.Native/bin/$(buildConfiguration)/x64

    - script: |
        chmod +x $(System.DefaultWorkingDirectory)/build/docker/build.sh
      displayName: 'Workaround: Restore wiped executable permission on build/docker/build.sh'

    - task: DockerCompose@0
      displayName: docker-compose run build
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) -e publishTargetFramework=$(publishTargetFramework) build

    - script: |
        chmod +x $(System.DefaultWorkingDirectory)/build/docker/Datadog.Trace.ClrProfiler.IntegrationTests.sh
      displayName: 'Workaround: Restore wiped executable permission on build/docker/Datadog.Trace.ClrProfiler.IntegrationTests.sh'

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests.Alpine.Core21
      condition: eq(variables['publishTargetFramework'], 'netcoreapp2.1')
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) IntegrationTests.Alpine.Core21

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests.Alpine.Core30
      condition: eq(variables['publishTargetFramework'], 'netcoreapp3.0')
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) IntegrationTests.Alpine.Core30

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests.Alpine.Core31
      condition: eq(variables['publishTargetFramework'], 'netcoreapp3.1')
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) IntegrationTests.Alpine.Core31

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests.Alpine.Core50
      condition: eq(variables['publishTargetFramework'], 'net5.0')
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) IntegrationTests.Alpine.Core50

    - publish: build_data
      artifact: $(Agent.JobName)_profiler-logs
      condition: succeededOrFailed()

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: test/**/*.trx
      condition: succeededOrFailed()

  - job: Linux_arm64
    pool: Arm64
    workspace:
      clean: all

    variables:
      TestAllPackageVersions: true

    steps:
    - checkout: none

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: build-managed
        path: $(System.DefaultWorkingDirectory)

    - download: current
      artifact: build-linux-tracer-home-arm64

    - task: CopyFiles@2
      inputs:
        sourceFolder: $(Pipeline.Workspace)/build-linux-tracer-home-arm64
        targetFolder: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.ClrProfiler.Native/bin/$(buildConfiguration)/arm64

    - script: |
        chmod +x $(System.DefaultWorkingDirectory)/build/docker/build.arm64.sh
      displayName: 'Workaround: Restore wiped executable permission on build/docker/build.arm64.sh'

    - task: DockerCompose@0
      displayName: docker-compose run build.arm64
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) -e publishTargetFramework=net5.0 build.arm64

    - script: |
        chmod +x $(System.DefaultWorkingDirectory)/build/docker/Datadog.Trace.ClrProfiler.IntegrationTests.arm64.sh
      displayName: 'Workaround: Restore wiped executable permission on build/docker/Datadog.Trace.ClrProfiler.IntegrationTests.arm64.sh'

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests.ARM64.Core50
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run -e TestAllPackageVersions=$(TestAllPackageVersions) -e buildConfiguration=$(buildConfiguration) IntegrationTests.ARM64.Core50

    - publish: build_data
      artifact: $(Agent.JobName)_profiler-logs
      condition: succeededOrFailed()

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: test/**/*.trx
      condition: succeededOrFailed()

- stage: benchmarks
  dependsOn: build_windows
  condition: and(succeeded(), false)
  jobs:

  #### Windows 

  - job: Windows
    pool: Benchmarks
    
    workspace:
      clean: all

    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent

    steps:

    - checkout: none

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: build-managed
        path: $(System.DefaultWorkingDirectory)

    - task: UseDotNet@2
      displayName: Install dotnet core sdk 5.0
      inputs:
        packageType: sdk
        version: $(dotnetCoreSdk5Version)

    - task: DotNetCoreCLI@2
      displayName: dotnet restore
      inputs:
        command: restore
        projects: src/**/*.csproj

    - task: DotNetCoreCLI@2
      displayName: Benchmarks
      inputs:
        command: 'run'
        projects: '$(System.DefaultWorkingDirectory)/test/benchmarks/Benchmarks.Trace/Benchmarks.Trace.csproj'
        arguments: '-c $(buildConfiguration) -f netcoreapp3.1 -- -r net472 netcoreapp3.1 -m -f * --iterationTime 2000'
      env:
        DD_ENV: CI
        DD_SERVICE: dd-trace-dotnet

    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: 'Start-Sleep -s 120'

- stage: dotnet_tool
  dependsOn: [build_windows, build_linux, build_macos]
  jobs:
  - job: build_runner_tool_and_standalone

    pool:
      vmImage: windows-2019

    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent

    steps:
    - template: steps/install-dotnet-5-sdk.yml
    - template: steps/restore-working-directory.yml
    
    - task: DownloadPipelineArtifact@2
      displayName: Download windows tracer home
      inputs:
        artifact: build-windows-tracer-home
        patterns: "!integrations.json"
        path: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/home

    - task: DownloadPipelineArtifact@2
      displayName: Download linux tracer home
      inputs:
        artifact: build-linux-tracer-home-debian
        patterns: "**/*.so"
        path: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/home/linux-x64

    - task: DownloadPipelineArtifact@2
      displayName: Download alpine tracer home
      inputs:
        artifact: build-linux-tracer-home-alpine
        patterns: "**/*.so"
        path: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/home/linux-musl-x64

    - task: DownloadPipelineArtifact@2
      displayName: Download alpine tracer home
      inputs:
        artifact: build-macos-tracer-home
        patterns: "**/*.dylib"
        path: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/home/osx-x64

    # Install the tracer latest stable release to attach the profiler to the build and test steps.
    # The script exposes the required environment variables to the following steps
    - task: PowerShell@2
      displayName: Install profiler latest release
      inputs:
        filePath: ./.azure-pipelines/setup_tracer.ps1

    - script: build.cmd BuildRunnerTool --skip
      displayName: Build Runner tool

    - script: build.cmd BuildStandaloneTool --skip
      displayName: Build Standalone tool

    - task: DeleteFiles@1
      displayName: 'Remove unneeded files'
      inputs:
        Contents: |
          $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Tool/!(*.nupkg)
          $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/win-x64/home*
          $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/win-x86/home*
          $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-x64/home*
          $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-musl-x64/home*
          $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/osx-x64/home*

    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/Release/Tool
      displayName: Uploading runner dotnet tool artifact
      artifact: runner-dotnet-tool
  
    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/Release/Console/publish/win-x64
      displayName: Uploading runner standalone win-x64 artifact
      artifact: runner-standalone-win-x64
  
    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/Release/Console/publish/win-x86
      displayName: Uploading runner standalone win-x86 artifact
      artifact: runner-standalone-win-x86
  
    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/Release/Console/publish/linux-x64
      displayName: Uploading runner standalone linux-x64 artifact
      artifact: runner-standalone-linux-x64
  
    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/Release/Console/publish/linux-musl-x64
      displayName: Uploading runner standalone linux-musl-x64 artifact
      artifact: runner-standalone-linux-musl-x64
  
    - publish: $(System.DefaultWorkingDirectory)/src/Datadog.Trace.Tools.Runner/bin/Release/Console/publish/osx-x64
      displayName: Uploading runner standalone osx-x64 artifact
      artifact: runner-standalone-osx-x64

- stage: upload
  dependsOn: [package_windows, build_linux]
  jobs:
  - job: s3_upload

    pool:
      vmImage: ubuntu-18.04

    steps:

    - download: current
      artifact: windows-msi-x64
      patterns: '**/*x64.msi'

    - download: current
      artifact: linux-packages
      patterns: '**/*amd64.deb'

    - script: |
        mkdir s3_upload
        mv $(Pipeline.Workspace)/windows-msi-x64/*.msi s3_upload/
        mv $(Pipeline.Workspace)/linux-packages/*.deb s3_upload/
      displayName: Move deb package and MSI to s3_upload folder

    # for prerelease versions, rename datadog-dotnet-apm-{version}-amd64.deb
    # to datadog-dotnet-apm-{version}-{tag}-amd64.deb (i.e. add the prerelease tag)
    # by copying most of the filename from datadog-dotnet-apm-{version}-{tag}-x64.msi
    - script: |
        MSI_NAME=$(ls s3_upload/*.msi)
        PACKAGE_NAME=${MSI_NAME::-8}
        echo Renaming deb package to $PACKAGE_NAME-amd64.deb
        mv s3_upload/*.deb $PACKAGE_NAME-amd64.deb
      displayName: Rename deb package name to match MSI name

    # Create index.txt file with the following format:
    # BRANCH_NAME
    # SHA
    # ARTIFACT WILDCARD (datadog-dotnet-apm-vX.X.X-*)
    # COMMIT AUTHOR
    # Note: For the branch name, normalize 'refs/heads/<branch>' to '<branch>' and 'refs/tags/<tag_name>' to 'tags/<tag_name>'
    - script: |
        INDEX_FILE=$(pwd)/s3_upload/index.txt
        echo $(Build.SourceBranch) | sed 's/refs\/heads\///g' | sed 's/refs\/tags\//tags\//g' >> $INDEX_FILE
        git rev-parse HEAD >> $INDEX_FILE
        pushd s3_upload && name=$(ls *.deb) && echo "${name::-9}*" >> $INDEX_FILE && popd
        git show -s --format='%ae' HEAD >> $INDEX_FILE
        echo Generated index.txt file:
        cat $INDEX_FILE
      displayName: Write index.txt

    - script: tree s3_upload
      displayName: 'tree s3_upload'

    - script: |
        sudo apt-get install -y unzip python3-setuptools
        curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
        unzip awscli-bundle.zip
        sudo python3 ./awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
        aws --version
      displayName: Install AWS CLI

    - script: aws configure set aws_access_key_id $SECRET
      displayName: Authenticate aws_access_key_id
      env:
        SECRET: $(AWS_ACCESS_KEY_ID)

    - script: aws configure set aws_secret_access_key $SECRET
      displayName: Authenticate aws_secret_access_key
      env:
        SECRET: $(AWS_SECRET_ACCESS_KEY)

    # by default, run this step on master branch only.
    # use "push_artifacts_to_s3" to override:
    #   "true": run this step
    #   "false": do NOT run this step
    #   else: run this stage if branch is master

    - script: aws s3 cp s3_upload s3://datadog-reliability-env/dotnet/ --recursive
      displayName: Upload deb, MSI, index.txt to s3
      condition: >
        and(
          succeeded(),
          ne(variables['push_artifacts_to_s3'], 'false'),
          or(
            eq(variables['push_artifacts_to_s3'], 'true'),
            eq(variables.isMainBranch, true)
          )
        )

- stage: throughput
  dependsOn: [build_linux]
  condition: and(succeeded(), false)
  jobs:

  #### Linux

  - job: Linux
    pool: Throughput
    
    workspace:
      clean: all

    steps:

    - checkout: none

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: build-managed
        path: $(System.DefaultWorkingDirectory)

    - download: current
      artifact: build-windows-tracer-home
      patterns: '**/win-x64/*.dll'

    - task: CopyFiles@2
      displayName: Copying windows native bindary from previous job
      inputs:
        sourceFolder: $(Pipeline.Workspace)/build-windows-tracer-home
        targetFolder: $(System.DefaultWorkingDirectory)/

    - download: current
      artifact: build-linux-tracer-home
      patterns: '**/*.so'

    - task: CopyFiles@2
      displayName: Copying native linux binary from previous job
      inputs:
        sourceFolder: $(Pipeline.Workspace)/build-linux-tracer-home
        targetFolder: $(System.DefaultWorkingDirectory)/

    - script: |
        cd $(System.DefaultWorkingDirectory)/build/crank
        chmod +x ./run.sh
        ./run.sh
      displayName: Crank
      env:
        DD_SERVICE: dd-trace-dotnet
